# -*- CPERL -*-
# /=====================================================================\ #
# | ifthen.sty                                                            | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Thanks to Kim Philipp Jablonski <kpjkpjkpjkpjkpjkpj@gmail.com>      | #
# | of the arXMLiv group for initial implementation                     | #
# |    http://arxmliv.kwarc.info/                                       | #
# | Released under the Gnu Public License                               | #
# | Released to the Public Domain                                       | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

######################################################

####################
# Helper Functions #
####################

sub ifthenExtendKeyVals {
  my ($key, $val, $keyval) = @_;
  return ToString($keyval) . ",$key=$val"; }

sub ifthenDeleteKeyVals {
  my ($key, $keyval) = @_;
  $keyval = ToString($keyval);
  $keyval =~ s/$key=[^,]*,*//g;
  $keyval =~ s/^,//;
  return $keyval; }

##########
# Macros #
##########

DefMacro('\ifthenelse{}{}{}', '\edef\ifthenResult{\ifthenParseExpression{} #1\ifthenStopExpressionParser}\typeout{Result: \ifthenResult}\expandafter\ifx\ifthenResult #2 \else #3 \fi');

DefMacroI('\ifthenParseExpression', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $tok) = @_;

    print "\n\n";
    print "{" . ToString($keyval) . "} - {" . ToString($tok) . "}\n";

    my $catc = ($tok->unlist)[0]->getCatcode;
    if ($catc == 12) {
      print "Found number!\n"; }

    #    if (defined $tok && defined $mem) {
    #      print "Parsing both\n"; }
    #    elsif (defined $mem) {
    #      print "Parsing memory\n"; }

    if (ToString($tok) eq '\ifthenStopExpressionParser') {
      print "Stop parsing\n";
      my $val = $keyval->getValue('prev');
      if (defined $val) {
        print "Fetching previous value: " . ToString($val) . "\n\n\n";
        return Tokens(T_CS(ToString($val)), T_CS('\ifthenTrue')); }
      else {
        print "\n\n\n";
        return T_CS('\ifthenTrue'); } }
    else {
      print "Continue\n";
      return Tokens($tok, T_BEGIN, Tokenize(ToString($keyval)), T_END); } });

DefMacroI('\and', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;
    #$keyval = ifthenDeleteKeyVals('prev', $keyval);
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ToString($keyval)), T_END); });

DefMacroI('\isodd', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $num) = @_;
    print "Calling \\isodd\n";
    my $res;
    if (ToString(Expand($num)) % 2 != 0) {
      $res = '\ifthenTrue'; }
    else {
      $res = '\ifthenFalse'; }
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

DefMacroI('\equal', 'RequiredKeyVals {}{}', sub {
    my ($gullet, $keyval, $first, $second) = @_;
    print "Calling \\equal\n";
    my $res;
    if (ToString(Expand($first)) eq ToString(Expand($second))) {
      $res = '\ifthenTrue'; }
    else {
      $res = '\ifthenFalse'; }
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

# some tex primitives to be able to deal with \ifx (there might be a better choice?)
Let('\ifthenTrue',  '\relax');
Let('\ifthenFalse', '\undefined');

DefMacro('\newboolean{}', sub {
    my ($gullet, $name) = @_;
    my $cs = T_CS('\if' . ToString($name));
    if (!isDefinable($cs)) {
      Error('ignore', $cs, $gullet,
        "Ignoring redefinition of boolean $name (ifthen package)");
      return; }
    return Tokens(T_CS('\newif'), $cs) });

DefMacro('\provideboolean{}', sub {
    my ($gullet, $name) = @_;
    my $cs = T_CS('\if' . ToString($name));
    return unless isDefinable($cs);
    return Tokens(T_CS('\newif'), $cs) });

DefMacro('\setboolean{}{}', sub {
    my ($gullet, $name, $value) = @_;
    return T_CS('\\' . ToString($name) . ToString($value)); });

######################################################

1;

# vim: ft=perl: noexpandtab:
