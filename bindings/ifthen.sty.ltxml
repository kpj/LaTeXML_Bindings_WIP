# -*- CPERL -*-
# /=====================================================================\ #
# | ifthen.sty                                                            | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Thanks to Kim Philipp Jablonski <kpjkpjkpjkpjkpjkpj@gmail.com>      | #
# | of the arXMLiv group for initial implementation                     | #
# |    http://arxmliv.kwarc.info/                                       | #
# | Released under the Gnu Public License                               | #
# | Released to the Public Domain                                       | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

######################################################

####################
# Helper Functions #
####################

sub ifthenExtendKeyVals {
  my ($key, $val, $keyval) = @_;
  $keyval = ToString($keyval) . ",$key=$val";
  $keyval =~ s/^ *,//;
  return $keyval; }

sub ifthenGetValuesFromKeyVals {
  my ($key, $keyval) = @_;
  my @vals     = ();
  my @rawpairs = $keyval->getPairs;
  while (@rawpairs) {
    if (ToString(shift(@rawpairs)) eq $key) {
      push(@vals, ToString(shift(@rawpairs))); } }
  return @vals; }

sub ifthenDeleteKeyVals {
  my ($key, $keyval) = @_;
  $keyval = ToString($keyval);
  $keyval =~ s/(^|[, ])$key=[^,]*,*//g;
  $keyval =~ s/^ *,//;
  $keyval =~ s/, *$//;
  $keyval =~ s/^\s+//;
  $keyval =~ s/\s+$//;
  return $keyval; }

sub ifthenHandleNegate {
  my ($keyval) = @_;
  my $neg = ToString($keyval->getValue('negate'));
  $keyval = ifthenDeleteKeyVals('negate', $keyval);
  $keyval = ifthenExtendKeyVals('negate', 'false', $keyval);
  return ($neg, $keyval); }

sub ifthenAnd {
  my ($first, $second) = @_;
  return ($first eq '\ifthenTrue' && $second eq '\ifthenTrue') ? '\ifthenTrue' : '\ifthenFalse'; }

sub ifthenOr {
  my ($first, $second) = @_;
  return ($first eq '\ifthenTrue' || $second eq '\ifthenTrue') ? '\ifthenTrue' : '\ifthenFalse'; }

sub ifthenReplaceInScope {
  my ($str, $expr, $repl) = @_;
  my ($bracount, $out) = (0, '');
  for (split('', $str)) {
    if ($_ eq '{') {
      $bracount++; }
    elsif ($_ eq '}') {
      $bracount--; }
    if ($_ eq $expr) {
      $out .= ($bracount == 0) ? $repl : $_; }
    else {
      $out .= $_; } }
  return $out; }

##########
# Macros #
##########

DefMacro('\ifthenelse{}{}{}', '\edef\ifthenResult{\ifthenParseExpression{negate=false} #1\ifthenStopExpressionParser}\typeout{Result: \ifthenResult}\expandafter\ifx\ifthenResult #2 \else #3 \fi');
DefMacro('\whiledo{}{}', '\ifthenelse{#1}{#2\whiledo{#1}{#2}}{}');

DefMacroI('\ifthenParseExpression', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $tok) = @_;
    my $currentRes   = '';
    my $keyvalgetter = $keyval;
    my $oldscope     = ToString($keyval->getValue('oldscope'));

    print "\n\n";
    print "{" . ToString($keyval) . "} - {" . ToString($tok) . "}\n";

    # parse numbers
    my $catc = ($tok->unlist)[0]->getCatcode;
    if ($catc == 12) {
      $tok = ToString($tok);
      if (index('=<>', $tok) != -1) {
        my $num = ToString($keyvalgetter->getValue('num'));
        $keyval = ifthenDeleteKeyVals('num', $keyval);
        $keyval = ifthenExtendKeyVals('firstnum', $num, $keyval);

        if ($tok eq '=') {
          $keyval = ifthenExtendKeyVals('comparator', 'eq', $keyval);
          print "Found equal sign!\n"; }
        elsif ($tok eq '<') {
          $keyval = ifthenExtendKeyVals('comparator', 'lt', $keyval);
          print "Found less than sign!\n"; }
        elsif ($tok eq '>') {
          $keyval = ifthenExtendKeyVals('comparator', 'gt', $keyval);
          print "Found greater than sign!\n"; } }
      else {
        my $num = ToString($keyvalgetter->getValue('num'));
        $keyval = ifthenDeleteKeyVals('num', $keyval);
        $keyval = ifthenExtendKeyVals('num', $num . $tok, $keyval);
        print "Found digit!\n"; } }
    else {
      my $comp = ToString($keyvalgetter->getValue('comparator'));
      if ($comp ne '') {
        my $first  = ToString($keyvalgetter->getValue('firstnum'));
        my $second = ToString($keyvalgetter->getValue('num'));

        my $neg;
        ($neg, $keyval) = ifthenHandleNegate($keyval);

        if ($comp eq 'eq') {
          $currentRes = (($neg eq 'true') ? $first ne $second : $first eq $second) ? '\ifthenTrue' : '\ifthenFalse'; }
        elsif ($comp eq 'lt') {
          $currentRes = (($neg eq 'true') ? $first ge $second : $first lt $second) ? '\ifthenTrue' : '\ifthenFalse'; }
        elsif ($comp eq 'gt') {
          $currentRes = (($neg eq 'true') ? $first le $second : $first gt $second) ? '\ifthenTrue' : '\ifthenFalse'; }

        # cleanup
        $keyval = ifthenDeleteKeyVals('firstnum',   $keyval);
        $keyval = ifthenDeleteKeyVals('comparator', $keyval);
        $keyval = ifthenDeleteKeyVals('num',        $keyval);

        print "Compare -> $currentRes\n"; } }

    # parse connectives
    my $operator = ToString($keyvalgetter->getValue('action'));
    if (defined $operator && $operator ne '') {
      my @operands = ifthenGetValuesFromKeyVals('prev', $keyvalgetter);
      if ($currentRes ne '') {
        push(@operands, $currentRes); }
      if (scalar @operands == 2) {
        print "Handling operator '$operator' with " . (scalar @operands) . " operands\n";
        if ($operator eq 'and') {
          $keyval = ifthenDeleteKeyVals('prev',   $keyval);
          $keyval = ifthenDeleteKeyVals('action', $keyval);
          $currentRes = ifthenAnd($operands[0], $operands[1]); }
        elsif ($operator eq 'or') {
          $keyval = ifthenDeleteKeyVals('prev',   $keyval);
          $keyval = ifthenDeleteKeyVals('action', $keyval);
          $currentRes = ifthenOr($operands[0], $operands[1]); } } }

    if (ToString($tok) eq '\ifthenStopExpressionParser') {
      print "Stop parsing\n";
      if ($currentRes eq '') {
        $currentRes = ToString($keyvalgetter->getValue('prev')); }
      (my $tmp = ToString($keyval)) =~ s/.*negate=([^,]*).*/$1/;    # *cough*
      if ($tmp eq 'true') {
        $currentRes = ($currentRes eq '\ifthenTrue') ? '\ifthenFalse' : '\ifthenTrue'; }
      print "Fetching previous value: " . ToString($currentRes) . "\n\n\n";
      return Tokens(T_CS(ToString($currentRes)), T_CS('\ifthenTrue')); }
    else {
      print "Continue\n";

      # incorporate current result
      if ($currentRes ne '') {
        $keyval = ifthenDeleteKeyVals('prev', $keyval);
        $keyval = ifthenExtendKeyVals('prev', $currentRes, $keyval); }

      # compute next token
      my $nextok = (index(ToString($keyval), 'num') != -1) ? T_CS('\ifthenParseExpression') : $tok;

      # fix old scope
      if ($oldscope ne '') {
        $keyval = ifthenDeleteKeyVals('oldscope', $keyval);
        $keyval = ifthenExtendKeyVals('oldscope', $oldscope, $keyval); }

      print "Next up: '" . ToString($nextok) . "' with '" . ToString($keyval) . "'\n";
      return Tokens($nextok, T_BEGIN, Tokenize(ToString($keyval)), T_END); } });

DefMacroI('\(', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;
    print "Going deeper!\n";

    # create a new scope
    $keyval = ToString($keyval);
    $keyval = ifthenReplaceInScope($keyval, ',', '@');    # compatibility issues
    my $newscope = 'negate=false,oldscope={' . $keyval . '}';

    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize($newscope), T_END); }); # go one level deeper with fresh scope (but save old one)

DefMacroI('\)', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;

    # assemble old scope
    my $oldscope = ToString($keyval->getValue('oldscope'));
    $oldscope =~ s/^{//;
    $oldscope = ifthenReplaceInScope($oldscope, '@', ',');    # compatibility issues
    $oldscope =~ s/}$//;

    # handle local environment
    my $preval = ToString($keyval->getValue('prev'));
    my $neg    = ToString($keyval->getValue('negate'));
    if ($neg eq 'true') {
      $preval = ($preval eq '\ifthenTrue') ? '\ifthenFalse' : '\ifthenTrue'; }

    my $newscope = $oldscope . ',prev=' . $preval;

    print "Going up with '" . $newscope . "'!\n";
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize($newscope), T_END); });

DefMacroI('\and', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;
    $keyval = ifthenExtendKeyVals('action', 'and', $keyval);
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize($keyval), T_END); });
Let('\AND', '\and');

DefMacroI('\or', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;
    $keyval = ifthenExtendKeyVals('action', 'or', $keyval);
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize($keyval), T_END); });
Let('\OR', '\or');

DefMacroI('\not', 'RequiredKeyVals', sub {
    my ($gullet, $keyval) = @_;
    my $neg = ToString($keyval->getValue('negate'));
    $keyval = ifthenDeleteKeyVals('negate', $keyval);
    $keyval = ifthenExtendKeyVals('negate', ($neg eq 'false') ? 'true' : 'false', $keyval);
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize($keyval), T_END); });
Let('\NOT', '\not');

DefMacroI('\isodd', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $num) = @_;
    print "Calling \\isodd\n";
    my $neg;
    ($neg, $keyval) = ifthenHandleNegate($keyval);
    my $res;
    if (ToString(Expand($num)) % 2 != 0) {
      $res = ($neg eq 'false') ? '\ifthenTrue' : '\ifthenFalse'; }
    else {
      $res = ($neg eq 'false') ? '\ifthenFalse' : '\ifthenTrue'; }
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

DefMacroI('\equal', 'RequiredKeyVals {}{}', sub {
    my ($gullet, $keyval, $first, $second) = @_;
    print "Calling \\equal\n";
    my $neg;
    ($neg, $keyval) = ifthenHandleNegate($keyval);
    my $res;
    if (ToString(Expand($first)) eq ToString(Expand($second))) {
      $res = ($neg eq 'false') ? '\ifthenTrue' : '\ifthenFalse'; }
    else {
      $res = ($neg eq 'false') ? '\ifthenFalse' : '\ifthenTrue'; }
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

DefMacroI('\isundefined', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $tok) = @_;
    print "Calling \\isundefined\n";
    my $neg;
    ($neg, $keyval) = ifthenHandleNegate($keyval);
    my $res;
    if (isDefinable(T_CS(ToString($tok)))) {
      $res = ($neg eq 'false') ? '\ifthenTrue' : '\ifthenFalse'; }
    else {
      $res = ($neg eq 'false') ? '\ifthenFalse' : '\ifthenTrue'; }
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

DefMacroI('\boolean', 'RequiredKeyVals {}', sub {
    my ($gullet, $keyval, $name) = @_;
    print "Calling \\boolean\n";
    my $neg;
    ($neg, $keyval) = ifthenHandleNegate($keyval);
    my $res = ToString(Expand(Tokens(T_CS('\\if' . ToString($name)), T_CS(($neg eq 'false') ? '\ifthenTrue' : '\ifthenFalse'), T_CS('\else'), T_CS(($neg eq 'false') ? '\ifthenFalse' : '\ifthenTrue'), T_CS('\fi'))));
    return Tokens(T_CS('\ifthenParseExpression'), T_BEGIN, Tokenize(ifthenExtendKeyVals('prev', $res, $keyval)), T_END); });

# some tex primitives to be able to deal with \ifx (there might be a better choice?)
Let('\ifthenTrue',  '\relax');
Let('\ifthenFalse', '\undefined');

DefMacro('\newboolean{}', sub {
    my ($gullet, $name) = @_;
    my $cs = T_CS('\if' . ToString($name));
    if (!isDefinable($cs)) {
      Error('ignore', $cs, $gullet,
        "Ignoring redefinition of boolean $name (ifthen package)");
      return; }
    return Tokens(T_CS('\newif'), $cs) });

DefMacro('\provideboolean{}', sub {
    my ($gullet, $name) = @_;
    my $cs = T_CS('\if' . ToString($name));
    return unless isDefinable($cs);
    return Tokens(T_CS('\newif'), $cs) });

DefMacro('\setboolean{}{}', sub {
    my ($gullet, $name, $value) = @_;
    return T_CS('\\' . ToString($name) . ToString($value)); });

######################################################

1;

# vim: ft=perl:
