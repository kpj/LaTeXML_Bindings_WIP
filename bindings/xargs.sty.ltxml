package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

######################################################

DefKeyVal('xargs', 'usedefault', undef, '');

#########
# Utils #
#########

# generate $paramlist
sub make_paramlist {
	my ($keyval, $nargs) = @_;
	my @paramlist = ();

	for my $i (1 .. $nargs) {
		my $val = ($keyval) ? $keyval->getValue($i) : undef;

		if(defined $val) {
			my $usedef = ($keyval) ? $keyval->getValue('usedefault') : undef;

			if(defined $usedef) {
				push(
					@paramlist, 
					LaTeXML::Core::Parameter->new(
						'XArgsOptional', 
						"XArgsOptional:" . $val->toString() . "|" . ToString($usedef), 
						[$val, $usedef]
					)
				);
			} else {
				push(
					@paramlist, 
					LaTeXML::Core::Parameter->new(
						'Optional', 
						"Default:" . $val->toString(), 
						[$val, $usedef]
					)
				);
			}
		} else {
			push(@paramlist, LaTeXML::Core::Parameter->new('Plain',"{}"));
		}
	}

	return LaTeXML::Core::Parameters->new(@paramlist);
}

# generate command prefix (\global, \long, ...; but not \outer)
sub extract_prefix {
	my ($star, $keyval) = @_;
	my $prefix = '';

	if(!defined $star) {
		# defaults to \long for unstarred form
		$prefix = '\\long';
	}

	if(defined $keyval) {
		my @pairs = $keyval->getPairs;
		while (@pairs) {
			my ($key, $value) = (shift(@pairs), shift(@pairs));

			if($key eq 'addprefix') {
				$prefix .= ToString($value);
			}
		}
	}

	return $prefix;
}

##########
# Macros #
##########

my @macros = (
#	{
#		'macro' => '\\name_of_macro',
#		'type' => 'cmd' | 'env', # influences macro generation
#		'func' => sub {
#			# does some extra work
#			# return 0 if macro should be defined, 1 otherwise
#		}
#	}
	{
		'macro' => '\\newcommandx',
		'type' => 'cmd',
		'func' => sub {
			my ($stomach, $cs) = @_;
			my $key = "defined:" . Stringify($cs);

			if(LookupValue($key)) {
				Error(
					'ignore', 
					$cs, 
					$stomach,
					"Ignoring redefinition (\\newcommandx) of '" . Stringify($cs) . "'"
				);
				return 1;
			}
			AssignValue($key => 1);

			return 0;
		}
	},
	{
		'macro' => '\\renewcommandx',
		'type' => 'cmd',
		'func' => sub {
			my ($stomach, $cs) = @_;

			AssignValue("defined:" . Stringify($cs) => 1);
			return 0;
		}
	},
	{
		'macro' => '\\providecommandx',
		'type' => 'cmd',
		'func' => sub {
			my ($stomach, $cs) = @_;

			if (LookupValue("defined:" . Stringify($cs)) || LookupDefinition($cs)) {
				return 1;
			}
			return 0;
		}
	},
	{
		'macro' => '\\DeclareRobustCommandx',
		'type' => 'cmd',
		'func' => sub {
			my ($stomach, $cs) = @_;
			# do something in here?
			return 0;
		}
	},
	{
		'macro' => '\\newenvironmentx',
		'type' => 'env',
		'func' => sub {
			my ($stomach, $name) = @_;

			if(LookupDefinition(T_CS("\\$name"))) {
				Error(
					'ignore', 
					$name, 
					$stomach,
					"Ignoring redefinition (\\newenvironmentx) of Environment '$name'"
				);
				return 1;
			}
			return 0;
		}
	},
	{
		'macro' => '\\renewenvironmentx',
		'type' => 'env',
		'func' => sub {
			my ($stomach, $name) = @_;

			AssignValue("defined:" . Stringify($name) => 1);
			return 0;
		}
	}
);

foreach(@macros) {
	my $macro_name = $_->{'macro'};
	my $logic_func = $_->{'func'};
	my $macro_type = $_->{'type'};

	my $arg_string = ' OptionalMatch:* ' . (($macro_type eq 'cmd')?'DefToken':'{}') . ' [] OptionalKeyVals:xargs {}' . (($macro_type eq 'cmd')?'':'{}');

	DefPrimitive(
		$macro_name . $arg_string,
		sub {
			my ($stomach, $star, $cs, $nargs, $defaults, $body) = @_;
			my @args = @_; # save arguments for later

			if($logic_func->($stomach, $cs)) {
				# maybe something failed and we have to return (no macros generated)
				return;
			}

			# fix $nargs
			$nargs = $nargs->toString if ref $nargs;
			$nargs = 0 unless $nargs;

			# handle global prefix
			my $prefix = extract_prefix($star, $defaults);
			my $is_global = (index($prefix, 'global') != -1) ? 1 : 0;

			if($macro_type eq 'cmd') {
				DefMacroI(
					$cs,
					make_paramlist($defaults, $nargs),
					$body,
					($is_global ? (scope=>'global'):())
				);
			} elsif($macro_type eq 'env') {
				my $preamble = $body;
				my $postamble = $args[-1];

				$cs = ToString($cs);

				DefMacroI(
					T_CS("\\$cs"), 
					make_paramlist($defaults, $nargs), 
					$preamble,
					($is_global ? (scope=>'global'):())
				);
				DefMacroI(
					T_CS("\\end$cs"), 
					undef, 
					$postamble,
					($is_global ? (scope=>'global'):())
				);
			}
		}
	);
}

DefPrimitive(
	'\CheckCommandx OptionalMatch:* DefToken [] OptionalKeyVals:xargs {}', 
	undef
);

######################################################

1;


# vim: ft=perl: noexpandtab:
