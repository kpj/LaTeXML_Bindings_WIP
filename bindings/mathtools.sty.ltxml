# -*- CPERL -*-
# /=====================================================================\ #
# | mathtools.sty                                                       | #
# | Implementation for LaTeXML                                          | #
# |=====================================================================| #
# | Part of LaTeXML:                                                    | #
# |  Public domain software, produced as part of work done by the       | #
# |  United States Government & not subject to copyright in the US.     | #
# |---------------------------------------------------------------------| #
# | Thanks to Kim Philipp Jablonski <kpjkpjkpjkpjkpjkpj@gmail.com>      | #
# | of the arXMLiv group for initial implementation                     | #
# |    http://arxmliv.kwarc.info/                                       | #
# | Released under the Gnu Public License                               | #
# | Released to the Public Domain                                       | #
# |---------------------------------------------------------------------| #
# | Bruce Miller <bruce.miller@nist.gov>                        #_#     | #
# | http://dlmf.nist.gov/LaTeXML/                              (o o)    | #
# \=========================================================ooo==U==ooo=/ #

package LaTeXML::Package::Pool;
use strict;
use warnings;
use LaTeXML::Package;

######################################################

###########
# Options #
###########

# handle special mathtools options
foreach my $option (qw(fixamsmath donotfixamsmathbugs allowspaces disallowspaces)) {
  DeclareOption($option, undef); }

# pass all other options to amsmath
DeclareOption(undef, sub {
    PassOptions('amsmath', 'sty', ToString(Digest(T_CS('\CurrentOption')))); });
ProcessOptions();
RequirePackage('amsmath', withoptions => 1);

#########
# Utils #
#########

# alignment stuff
sub MTMatrixTemplate {
  my ($type) = @_;
  my $alty = {};
  if ($type eq 'c') {
    $alty = { before => Tokens(T_CS('\hfil')), after => Tokens(T_CS('\hfil')) }; }
  elsif ($type eq 'l') {
    $alty = { after => Tokens(T_CS('\hfil')) }; }
  elsif ($type eq 'r') {
    $alty = { before => Tokens(T_CS('\hfil')) }; }
  my $stuff = LaTeXML::Core::Alignment::Template->new(repeated => [$alty]);
  return $stuff; }

##########
# Macros #
##########

# 3

DefConstructor('\mathtoolsset {}', "");

## 3.1

DefConstructor('\mathllap [] {}',       "#2");
DefConstructor('\mathrlap [] {}',       "#2");
DefConstructor('\mathmbox {}',          "#1");
DefConstructor('\mathclap [] {}',       "#2");
DefConstructor('\clap {}',              "#1");
DefConstructor('\mathmakebox [] [] {}', "#3");
DefConstructor('\cramped [] {}',        "#2");
DefConstructor('\crampedllap [] {}',    "#2");
DefConstructor('\crampedrlap [] {}',    "#2");
DefConstructor('\crampedclap [] {}',    "#2");
DefConstructor('\smashoperator [] {}',  "#2");
DefConstructor('\adjustlimits',         "");     # just some wrapper for \lim
DefConstructor('\SwapAboveDisplaySkip', "");

## 3.2

DefPrimitive('\newtagform {} [] {} {}', sub {
    my ($stomach, $name, $style, $open, $close) = @_;
    my $body = Tokens(T_CS('\def'), T_CS('\fnum@equation'), T_BEGIN, T_BEGIN, $open->unlist, (($style) ? $style->unlist : ()), T_BEGIN, T_CS('\theequation'), T_END, $close->unlist, T_END, T_END);
    my $cs = T_CS('\taggy' . ToString($name));
    if (!isDefinable($cs)) {
      Error('ignore', $cs, $stomach,
        "Ignoring redefinition (\\newtagform) of '" . Stringify($cs) . "'");
      return; }
    DefMacroI($cs, undef, $body, scope => 'global'); });
DefPrimitive('\renewtagform {} [] {} {}', sub {
    my ($stomach, $name, $style, $open, $close) = @_;
    my $body = Tokens(T_CS('\def'), T_CS('\fnum@equation'), T_BEGIN, T_BEGIN, $open->unlist, (($style) ? $style->unlist : ()), T_BEGIN, T_CS('\theequation'), T_END, $close->unlist, T_END, T_END);
    my $cs  = T_CS('\taggy' . ToString($name));
    my $key = "defined:" . Stringify($cs);
    DefMacroI($cs, undef, $body, scope => 'global'); });
DefMacro('\usetagform {}', '\csname taggy#1\endcsname');

Let('\refeq', '\ref');

## 3.3

DefConstructor('\xleftrightarrow[]{}',    # not centered anymore
  "?#1("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftrightarrow' role='METARELOP'>\x{2194}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftrightarrow' role='METARELOP'>\x{2194}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xLeftarrow[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xLeftarrow' role='ARROW'>\x{21D0}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xLeftarrow' role='ARROW'>\x{21D0}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xRightarrow[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xRightarrow' role='ARROW'>\x{21D2}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xRightarrow' role='ARROW'>\x{21D2}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xLeftrightarrow[]{}',    # looks stretched
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xLeftrightarrow' role='ARROW'>\x{21D4}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xLeftrightarrow' role='ARROW'>\x{21D4}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xhookleftarrow[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xhookleftarrow' role='ARROW'>\x{21A9}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xhookleftarrow' role='ARROW'>\x{21A9}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xhookrightarrow[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xhookrightarrow' role='ARROW'>\x{21AA}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xhookrightarrow' role='ARROW'>\x{21AA}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xmapsto[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xmapsto' role='ARROW'>\x{21A6}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xmapsto' role='ARROW'>\x{21A6}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xrightharpoondown[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightharpoondown' role='ARROW'>\x{21C1}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightharpoondown' role='ARROW'>\x{21C1}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xrightharpoonup[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightharpoonup' role='ARROW'>\x{21C0}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightharpoonup' role='ARROW'>\x{21C0}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xleftharpoondown[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftharpoondown' role='ARROW'>\x{21BD}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xlefttharpoondown' role='ARROW'>\x{21BD}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xleftharpoonup[]{}',
  "?#1("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftharpoonup' role='ARROW'>\x{21BC}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='ARROW'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftharpoonup' role='ARROW'>\x{21BC}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xrightleftharpoons[]{}',
  "?#1("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightleftharpoons' role='METARELOP'>\x{21CC}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xrightleftharpoons' role='METARELOP'>\x{21CC}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefConstructor('\xleftrightharpoons[]{}',
  "?#1("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='UNDERACCENT'>#1</ltx:XMWrap>"
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftrightharpoons' role='METARELOP'>\x{21CB}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . "</ltx:XMApp>"
    . ")("
    . "<ltx:XMApp role='METARELOP'>"
    . "<ltx:XMWrap role='OVERACCENT'>#2</ltx:XMWrap>"
    . "<ltx:XMTok name='xleftrightharpoons' role='METARELOP'>\x{21CB}</ltx:XMTok>"
    . "</ltx:XMApp>"
    . ")",
  properties => { font => sub { LookupValue('font')->specialize("\x{2026}"); } });

DefMacro('\overbracket [] [] {}', '\@overbracket {#3}'); # args: [<rule thickness>] [<bracket height>] {<arg>}
DefMacro('\underbracket [] [] {}', '\@underbracket {#3}');
DefMath('\@overbracket Digested',  "\x{FE48}", operator_role => 'OVERACCENT',  scriptpos => 'mid');
DefMath('\@underbracket Digested', "\x{FE47}", operator_role => 'UNDERACCENT', scriptpos => 'mid');
Let('\LaTeXunderbrace', '\underbrace');
Let('\LaTeXoverbrace',  '\overbrace');

# 3.4

DefPrimitive('\@MTSmatrix@bindings [] {} {}', sub {
    my ($stomach, $col, $open, $close) = @_;
    $open  = ToString($open);
    $close = ToString($close);

    # handle column type
    $col = ToString($col);
    $col = ($col ne '') ? $col : 'c';    # defaults to [c]

    # fix for \{ and \}
    if (substr($open, 0, 1) eq '\\') {
      $open = substr($open, 1); }
    if (substr($close, 0, 1) eq '\\') {
      $close = substr($close, 1); }

    alignmentBindings(MTMatrixTemplate($col), 'math', attributes => { name => 'Matrix', open => $open, close => $close }); });

# starred normal matrices
DefMacro('\csname matrix*\endcsname []', '\@MTSmatrix@bindings[#1]{}{}\@@MTSmatrix{matrix*}[#1]\@start@alignment');
DefMacro('\csname pmatrix*\endcsname []', '\@MTSmatrix@bindings[#1]{(}{)}\@@MTSmatrix{pmatrix*}[#1]\@start@alignment');
DefMacro('\csname bmatrix*\endcsname []', '\@MTSmatrix@bindings[#1]{[}{]}\@@MTSmatrix{bmatrix*}[#1]\@start@alignment');
DefMacro('\csname Bmatrix*\endcsname []', '\@MTSmatrix@bindings[#1]{\{}{\}}\@@MTSmatrix{Bmatrix*}[#1]\@start@alignment');
DefMacro('\csname vmatrix*\endcsname []', '\@MTSmatrix@bindings[#1]{|}{|}\@@MTSmatrix{vmatrix*}[#1]\@start@alignment');
DefMacro('\csname Vmatrix*\endcsname []', '\@MTSmatrix@bindings[#1]{' . "\x{2016}" . '}{' . "\x{2016}" . '}\@@MTSmatrix{Vmatrix*}[#1]\@start@alignment');

DefMacro('\csname endmatrix*\endcsname',  '\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endpmatrix*\endcsname', '\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endbmatrix*\endcsname', '\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endBmatrix*\endcsname', '\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endvmatrix*\endcsname', '\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endVmatrix*\endcsname', '\@finish@alignment\@end@MTSmatrix');

DefPrimitive('\@end@MTSmatrix', sub { $_[0]->egroup; });
DefConstructor('\@@MTSmatrix {} [] DigestedBody', '#3',
  beforeDigest => sub { $_[0]->bgroup; },
  reversion => '\begin{#1}[#2]#3\end{#1}');

# starred small matrices
DefMacro('\csname smallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{}{}\@@MTSmatrix{smallmatrix*}[#1]\@start@alignment');
DefMacro('\csname psmallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{(}{)}\@@MTSmatrix{psmallmatrix*}[#1]\@start@alignment');
DefMacro('\csname bsmallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{[}{]}\@@MTSmatrix{bsmallmatrix*}[#1]\@start@alignment');
DefMacro('\csname Bsmallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{\{}{\}}\@@MTSmatrix{Bsmallmatrix*}[#1]\@start@alignment');
DefMacro('\csname vsmallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{|}{|}\@@MTSmatrix{vsmallmatrix*}[#1]\@start@alignment');
DefMacro('\csname Vsmallmatrix*\endcsname []', '\@hidden{\scriptsize}\@MTSmatrix@bindings[#1]{' . "\x{2016}" . '}{' . "\x{2016}" . '}\@@MTSmatrix{Vsmallmatrix*}[#1]\@start@alignment');

DefMacro('\csname endsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endpsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endbsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endBsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endvsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\csname endVsmallmatrix*\endcsname', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');

# non-starred small matrices
DefMacro('\psmallmatrix', '\@hidden{\scriptsize}\@MTSmatrix@bindings{(}{)}\@@MTSmatrix{psmallmatrix}[#1]\@start@alignment');
DefMacro('\bsmallmatrix', '\@hidden{\scriptsize}\@MTSmatrix@bindings{[}{]}\@@MTSmatrix{bsmallmatrix}[#1]\@start@alignment');
DefMacro('\Bsmallmatrix', '\@hidden{\scriptsize}\@MTSmatrix@bindings{\{}{\}}\@@MTSmatrix{Bsmallmatrix}[#1]\@start@alignment');
DefMacro('\vsmallmatrix', '\@hidden{\scriptsize}\@MTSmatrix@bindings{|}{|}\@@MTSmatrix{vsmallmatrix}[#1]\@start@alignment');
DefMacro('\Vsmallmatrix', '\@hidden{\scriptsize}\@MTSmatrix@bindings{' . "\x{2016}" . '}{' . "\x{2016}" . '}\@@MTSmatrix{Vsmallmatrix}[#1]\@start@alignment');

DefMacro('\endpsmallmatrix', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\endbsmallmatrix', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\endBsmallmatrix', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\endvsmallmatrix', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');
DefMacro('\endVsmallmatrix', '\@hidden{\scriptsize}\@finish@alignment\@end@MTSmatrix');

# {multlined}

# cases
DefConstructor('\@@cases@mt {} DigestedBody',
  '#2',
  reversion    => '\begin{#1}#2\end{#1}',
  beforeDigest => sub {
    $_[0]->bgroup; });

DefPrimitive('\@cases@bindings {}{}{}{}{}', sub {
    my ($stomach, $style1, $style2, $open, $close, $type) = @_;    # $type = m | t
    $open  = ToString($open);
    $close = ToString($close);
    $type  = ToString($type);

    # fix for \{ and \}
    if (substr($open, 0, 1) eq '\\') {
      $open = substr($open, 1); }
    if (substr($close, 0, 1) eq '\\') {
      $close = substr($close, 1); }

    my $templ = LaTeXML::Core::Alignment::Template->new(columns => [
        { before => Tokens($style1), after => Tokens(T_CS('\hfil')) },
        { before => Tokens(($type eq 't') ? T_MATH : (), $style2), after => Tokens(($type eq 't') ? T_MATH : (), T_CS('\hfil')) }]);

    alignmentBindings($templ, 'math', attributes => { meaning => 'cases', open => $open, close => $close }); });

DefMacro('\dcases', '\@cases@bindings{\displaystyle}{\displaystyle}{\{}{}{m}\@@cases@mt{dcases}\@start@alignment');
DefMacro('\enddcases', '\@finish@alignment\@end@cases');

DefMacro('\csname dcases*\endcsname', '\@cases@bindings{\displaystyle}{\displaystyle}{\{}{}{t}\@@cases@mt{dcases*}\@start@alignment');
DefMacro('\csname enddcases*\endcsname', '\@finish@alignment\@end@cases');

DefMacro('\csname rcases\endcsname', '\@cases@bindings{\textstyle}{\textstyle}{}{\}}{m}\@@cases@mt{rcases}\@start@alignment');
DefMacro('\csname endrcases\endcsname', '\@finish@alignment\@end@cases');

DefMacro('\csname rcases*\endcsname', '\@cases@bindings{\textstyle}{\textstyle}{}{\}}{t}\@@cases@mt{rcases*}\@start@alignment');
DefMacro('\csname endrcases*\endcsname', '\@finish@alignment\@end@cases');

DefMacro('\csname drcases\endcsname', '\@cases@bindings{\displaystyle}{\displaystyle}{}{\}}{m}\@@cases@mt{drcases}\@start@alignment');
DefMacro('\csname enddrcases\endcsname', '\@finish@alignment\@end@cases');

DefMacro('\csname drcases*\endcsname', '\@cases@bindings{\displaystyle}{\displaystyle}{}{\}}{t}\@@cases@mt{drcases*}\@start@alignment');
DefMacro('\csname enddrcases*\endcsname', '\@finish@alignment\@end@cases');

DefMacro('\csname cases*\endcsname', '\@cases@bindings{\textstyle}{\textstyle}{\{}{}{t}\@@cases@mt{cases*}\@start@alignment');
DefMacro('\csname endcases*\endcsname', '\@finish@alignment\@end@cases');

# 3.6

DefPrimitive('\DeclarePairedDelimiter DefToken {}{}', sub {
    my ($gullet, $cs, $ldel, $rdel) = @_;
    my $cmd = substr(ToString($cs), 1);

    DefMacroI('\MT@delim@' . $cmd . '@star@wrapper', '{}{}{}',
      '\mathopen{}\mathclose\bgroup #1 #2 \aftergroup\egroup #3');
    DefMacroI('\MT@delim@' . $cmd . '@nostar@wrapper', '{}{}{}',
      '\mathopen{#1}#2\mathclose{#3}');

    DefMacroI('\MT@delim@' . $cmd . '@star', '{}',
'\csname MT@delim@' . $cmd . '@star@wrapper\endcsname{\left' . ToString($ldel) . '}{#1}{\right' . ToString($rdel) . '}');
    DefMacroI('\MT@delim@' . $cmd . '@nostar', '[]{}',
'\csname MT@delim@' . $cmd . '@nostar@wrapper\endcsname{#1 ' . ToString($ldel) . '}{#2}{#1 ' . ToString($rdel) . '}');

    DefMacro(ToString($cs), '\@ifstar{\MT@delim@' . $cmd . '@star}{\MT@delim@' . $cmd . '@nostar}'); });

DefPrimitive('\DeclarePairedDelimiterX DefToken [] {} {} {}', sub {
    my ($stomach, $cs, $nargs, $ldel, $rdel, $body) = @_;

    # fix $nargs
    $nargs = $nargs->toString if ref $nargs;
    $nargs = 0 unless $nargs;

    DefMacroI(T_CS(ToString($cs) . '@inner'), join('', map { '{}' } (1 .. $nargs)),
      Tokens($body->unlist, T_CS($cs . '@after')));
    DefMacroI($cs, 'OptionalMatch:* []', sub {
        my ($gullet, $star, $opt) = @_;
        return (($star ? T_CS('\left') : ((defined $opt) ? $opt->unlist : ())),
          $ldel->unlist,
          T_CS('\def'), T_CS('\delimsize'), T_BEGIN, ($opt ? $opt->unlist : ()), T_END,
          T_CS('\def'), T_CS($cs . '@after'), T_BEGIN, ($star ? T_CS('\right') : ((defined $opt) ? $opt->unlist : ())), $rdel->unlist, T_END,
          T_CS(ToString($cs) . '@inner')); }); });

DefPrimitive('\DeclarePairedDelimiterXPP DefToken [] {} {} {} {} {}', sub {
    my ($stomach, $cs, $nargs, $precode, $ldel, $rdel, $postcode, $body) = @_;

    # fix $nargs
    $nargs = $nargs->toString if ref $nargs;
    $nargs = 0 unless $nargs;

    DefMacroI(T_CS(ToString($cs) . '@inner'), join('', map { '{}' } (1 .. $nargs)),
      Tokens($body->unlist, T_CS($cs . '@after'), $postcode->unlist));
    DefMacroI($cs, 'OptionalMatch:* []', sub {
        my ($gullet, $star, $opt) = @_;
        return ($precode->unlist,
          ($star ? T_CS('\left') : ((defined $opt) ? $opt->unlist : ())),
          $ldel->unlist,
          T_CS('\def'), T_CS('\delimsize'), T_BEGIN, ($opt ? $opt->unlist : ()), T_END,
          T_CS('\def'), T_CS($cs . '@after'), T_BEGIN, ($star ? T_CS('\right') : ((defined $opt) ? $opt->unlist : ())), $rdel->unlist, T_END,
          T_CS(ToString($cs) . '@inner')); }); });

# only applies to macros defined with \DeclarePairedDelimiter
DefPrimitive('\reDeclarePairedDelimiterInnerWrapper DefToken {} {}', sub {
    my ($stomach, $cs, $nstar, $body) = @_;
    DefMacroI('\MT@delim@' . (substr(ToString($cs), 1)) . '@' . ToString($nstar) . '@wrapper', '{}{}{}', $body); });

# 3.7

DefMath('\lparen', '(', role => 'OPEN',  stretchy => 'false');
DefMath('\rparen', ')', role => 'CLOSE', stretchy => 'false');

DefMathI('\vcentcolon',    undef, ':', role => 'RELOP');
DefMathI('\ordinarycolon', undef, ':', role => 'RELOP');

DefMath('\dblcolon', "::", role => 'RELOP');
# taken from txfonts.sty.ltxml
DefMath('\coloneqq',    "\x{2254}",   role => 'RELOP');
DefMath('\Coloneqq',    "\x{2A74}",   role => 'RELOP');
DefMath('\coloneq',     ":-",         role => 'RELOP');
DefMath('\Coloneq',     "::-",        role => 'RELOP');
DefMath('\eqqcolon',    "\x{2255}",   role => 'RELOP');
DefMath('\Eqqcolon',    "=::",        role => 'RELOP');
DefMath('\eqcolon',     "-:",         role => 'RELOP');
DefMath('\Eqcolon',     "-::",        role => 'RELOP');
DefMath('\colonapprox', ":\x{2248}",  role => 'RELOP');
DefMath('\Colonapprox', "::\x{2248}", role => 'RELOP');
DefMath('\colonsim',    ":\x{223C}",  role => 'RELOP');
DefMath('\Colonsim',    "::\x{223C}", role => 'RELOP');

DefMathI('\nuparrow', undef, UTF(0x2909), role => 'ARROW'); # could not find arrow with vertical line
DefMathI('\ndownarrow', undef, UTF(0x2908), role => 'ARROW');    # see above
DefMathI('\bigtimes', undef, UTF(0xD7), role => 'MULOP', font => { size => 'Big' }, scriptpos => \&doScriptpos);

######################################################

1;

# vim: ft=perl: expandtab:
